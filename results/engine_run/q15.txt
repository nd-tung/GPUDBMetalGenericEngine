--- Running (Engine Host) ---
[Planner] Parsed aliases:
[Planner]   'total_revenue' -> 'sum(l_extendedprice * (1 - l_discount))'
[Planner]   'sum(l_extendedprice*(1-l_discount))' -> 'total_revenue'
[Planner]   'supplier_no' -> 'l_suppkey'
[Planner]   'l_suppkey' -> 'supplier_no'
[Planner] Traversing node: CTE
[Planner] Traversing: CTE
DEBUG: CTE Node extra_info keys:
  CTE Key: CTE Name
  CTE Key: Estimated Cardinality
  CTE Key: Table Index
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: HASH_GROUP_BY
[Planner] Traversing: HASH_GROUP_BY
[Planner] Entering children traversal block. Name: hash_group_by Children: 1
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: SEQ_SCAN 
[Planner] Traversing: SEQ_SCAN 
[Planner] Entering children traversal block. Name: seq_scan  Children: 0
[Planner] Parsing Projections for SEQ_SCAN 
[Planner] Proj: l_suppkey
[Planner] Proj: l_extendedprice
[Planner] Proj: l_discount
DEBUG: Scan table determined as: 'lineitem'
DEBUG: Pushing SCAN node for SEQ_SCAN . Table=lineitem
[Planner] Generating Scan: lineitem at index 0 Plan: 6133541256
[Planner] Node SEQ_SCAN  output projections: l_suppkey, l_extendedprice, l_discount, 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: l_suppkey
[Planner] Proj: l_extendedprice
[Planner] Proj: l_discount
[Planner] Node PROJECTION output projections: l_suppkey, l_extendedprice, l_discount, 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: l_suppkey
[Planner] Proj: (l_extendedprice * (1.00 - l_discount))
[Planner] Forcing keep of global column: l_extendedprice
[Planner] Forcing keep of global column: l_discount
[Planner] Node PROJECTION output projections: l_suppkey, (l_extendedprice * (1.00 - l_discount)), 
[Planner] Parsing agg string: 'sum_no_overflow(#1)'
[Planner] Resolved agg: sum_no_overflow((l_extendedprice * (1.00 - l_discount)))
[Planner] inputExpr '(l_extendedprice * (1.00 - l_discount))' exists in child projections. Treating as Column.
[Planner] Looking up agg alias: 'sum((l_extendedprice*(1-l_discount)))'
[Planner] Found alias with reduced parens: 'sum(l_extendedprice*(1-l_discount))'
[Planner] Found alias for agg: total_revenue
[Planner] Pushing spec with outputName='total_revenue'
[Planner] Node HASH_GROUP_BY output projections: l_suppkey, total_revenue, 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: l_suppkey
[Planner] Proj: total_revenue
[Planner] Node PROJECTION output projections: l_suppkey, total_revenue, 
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: ORDER_BY
[Planner] Traversing: ORDER_BY
[Planner] Entering children traversal block. Name: order_by Children: 1
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: HASH_JOIN
[Planner] Traversing: HASH_JOIN
[Planner] [TraverseNode] Logic for JOIN: HASH_JOIN
[Planner] Checking RHS capture for Join HASH_JOIN
[Planner] Inspecting RHS node HASH_JOIN
[Planner] RHS is complex (tryCapture failed). Using Traversal-First Strategy.
[Planner] Traversing node: HASH_JOIN
[Planner] Traversing: HASH_JOIN
[Planner] [TraverseNode] Logic for JOIN: HASH_JOIN
[Planner] Checking RHS capture for Join HASH_JOIN
[Planner] Inspecting RHS node PROJECTION
[Planner] RHS is complex (tryCapture failed). Using Traversal-First Strategy.
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: UNGROUPED_AGGREGATE
[Planner] Traversing: UNGROUPED_AGGREGATE
[Planner] Entering children traversal block. Name: ungrouped_aggregate Children: 1
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: UNGROUPED_AGGREGATE
[Planner] Traversing: UNGROUPED_AGGREGATE
[Planner] Entering children traversal block. Name: ungrouped_aggregate Children: 1
[Planner] Traversing node: PROJECTION
[Planner] Traversing: PROJECTION
[Planner] Entering children traversal block. Name: projection Children: 1
[Planner] Traversing node: CTE_SCAN
[Planner] Traversing: CTE_SCAN
[Planner] Entering children traversal block. Name: cte_scan Children: 0
DEBUG: Resolved CTE_SCAN table from index 0 -> revenue
DEBUG: Scan table determined as: 'revenue'
DEBUG: Pushing SCAN node for CTE_SCAN. Table=revenue
[Planner] Generating Scan: revenue at index 6 Plan: 6133541256
[Planner] Node CTE_SCAN output projections: 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: total_revenue
[Planner] Projection: resolving alias 'total_revenue' -> 'sum(l_extendedprice * (1 - l_discount))'
[Planner] Node PROJECTION output projections: total_revenue, 
[Planner] Processing aggregate: 'max(total_revenue)'
[Planner] Node UNGROUPED_AGGREGATE output projections: max(total_revenue), 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: max(total_revenue)
[Planner] Node PROJECTION output projections: max(total_revenue), 
[Planner] Processing aggregate: '"first"(max(total_revenue))'
[Planner] Processing aggregate: 'count_star()'
[Planner] Node UNGROUPED_AGGREGATE output projections: "first"(max(total_revenue)), count_star(), 
[Planner] Parsing Projections for PROJECTION
[Planner] Fixing split CASE projection. Appending next line.
[Planner] Proj: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END
[Planner] Node PROJECTION output projections: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END, 
[Planner] Traversing node: CTE_SCAN
[Planner] Traversing: CTE_SCAN
[Planner] Entering children traversal block. Name: cte_scan Children: 0
DEBUG: Resolved CTE_SCAN table from index 0 -> revenue
DEBUG: Scan table determined as: 'revenue'
DEBUG: Pushing SCAN node for CTE_SCAN. Table=revenue
[Planner] Generating Scan: revenue at index 14 Plan: 6133541256
[Planner] Node CTE_SCAN output projections: 
[Planner] Creating JOIN 'HASH_JOIN'. CapturedRightTable: 'tmpl_join_13'
[Planner] Pre-resolved Condition: 'total_revenue = SUBQUERY'
[Planner] ChildProjs size: 1
  #0: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END
[Planner] Keeping SUBQUERY token (RHS is complex: 'CASE  WHEN ((count_star() > 1)) THEN ("e...')
[Planner] Resolved Condition: 'total_revenue = SUBQUERY'
DEBUG_JOIN_EMISSION: Node='HASH_JOIN' capturedRHS=true capturedRightTable='tmpl_join_13'
[Planner] Join Key Analysis: l => , r => 
[Planner] Captured RHS Table: tmpl_join_13
[Planner] RHS Tables: tmpl_join_13, 
[Planner] Checking matchesRHS: 
[Planner] Checking matchesRHS: 
[Planner] Node HASH_JOIN output projections: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END, 
[Planner] Traversing node: SEQ_SCAN 
[Planner] Traversing: SEQ_SCAN 
[Planner] Entering children traversal block. Name: seq_scan  Children: 0
[Planner] Parsing Projections for SEQ_SCAN 
[Planner] Proj: s_suppkey
[Planner] Proj: s_name
[Planner] Proj: s_address
[Planner] Proj: s_phone
DEBUG: Scan table determined as: 'supplier'
DEBUG: Pushing SCAN node for SEQ_SCAN . Table=supplier
[Planner] Generating Scan: supplier at index 17 Plan: 6133541256
[Planner] Node SEQ_SCAN  output projections: s_suppkey, s_name, s_address, s_phone, 
[Planner] Creating JOIN 'HASH_JOIN'. CapturedRightTable: 'tmpl_join_16'
[Planner] Pre-resolved Condition: 's_suppkey = supplier_no'
[Planner] ChildProjs size: 5
  #0: s_suppkey
  #1: s_name
  #2: s_address
  #3: s_phone
  #4: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END
[Planner] Resolved Condition: 's_suppkey = supplier_no'
DEBUG_JOIN_EMISSION: Node='HASH_JOIN' capturedRHS=true capturedRightTable='tmpl_join_16'
[Planner] Join Key Analysis: l => supplier, r => 
[Planner] Captured RHS Table: tmpl_join_16
[Planner] RHS Tables: tmpl_join_16, 
[Planner] Checking matchesRHS: supplier
[Planner] Checking matchesRHS: 
[Planner] Node HASH_JOIN output projections: s_suppkey, s_name, s_address, s_phone, CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END, 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: s_suppkey
[Planner] Proj: s_name
[Planner] Proj: s_address
[Planner] Proj: s_phone
[Planner] Proj: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END
[Planner] Node PROJECTION output projections: s_suppkey, s_name, s_address, s_phone, CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END, 
[Planner] Node ORDER_BY output projections: s_suppkey, s_name, s_address, s_phone, CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END, 
[Planner] Parsing Projections for PROJECTION
[Planner] Proj: s_suppkey
[Planner] Proj: s_name
[Planner] Proj: s_address
[Planner] Proj: s_phone
[Planner] Proj: CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END
[Planner] Node PROJECTION output projections: s_suppkey, s_name, s_address, s_phone, CASE  WHEN ((count_star() > 1)) THEN ("error"('More than one row returned by a subquery used as an expression - scalar subqueries can only return a single row. Use "SET scalar_subquery_error_on_multiple_rows=false" to revert to previous behavior of returning a random row.')) ELSE "first"(max(total_revenue)) END, 
[Main] Using GpuExecutor generic executor.
[GPU] Device: Apple M3 Ultra
[GPU] Pre-compiled metallib not found, compiling shaders at runtime...
[GPU] Runtime Metal shader compilation succeeded (124 KB source).
---------------------------------------------------
======================RESULT=======================
---------------------------------------------------
s_suppkey|total_revenue|s_name|s_address|s_phone|
8449|1772627.25|Supplier#000008449|Wp34zim9qYFbVctdW|20-469-856-8873|
---------------------------------------------------
Planning time: 20.85 ms
Data Load Time (Disk+Upload): 8351.93 ms
GPU kernels time: 15.49 ms
CPU postprocess time: 31.87 ms
Total Internal Pipeline time: 8399.29 ms
Total Host Execution time: 8399.33 ms
Total Wall time (Plan+Exec): 8420.18 ms
---------------------------------------------------
GPU Kernel Timing Summary:
─────────────────────────────────────────
  compact        :    2.244 ms (14.487%) [3 calls]
  filter         :    7.508 ms (48.469%) [3 calls]
  gather         :    4.044 ms (26.102%) [9 calls]
  groupby        :    1.213 ms (7.829%) [3 calls]
  hash_join_probe_u32:    0.183 ms (1.183%) [1 calls]
  sort           :    0.299 ms (1.929%) [1 calls]
─────────────────────────────────────────
  TOTAL GPU TIME: 15.491 ms
  Kernel invocations: 20
